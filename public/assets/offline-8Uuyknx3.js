const b="gatepass-offline";function a(){return new Promise((e,s)=>{const o=indexedDB.open(b,5);o.onupgradeneeded=()=>{const t=o.result;t.objectStoreNames.contains("students")||t.createObjectStore("students",{keyPath:"id"}),t.objectStoreNames.contains("logs")||t.createObjectStore("logs",{keyPath:"_id"}),t.objectStoreNames.contains("studentProfile")||t.createObjectStore("studentProfile",{keyPath:"key"}),t.objectStoreNames.contains("studentLogs")||t.createObjectStore("studentLogs",{keyPath:"_id"}),t.objectStoreNames.contains("studentCacheBySid")||t.createObjectStore("studentCacheBySid",{keyPath:"sid"}),t.objectStoreNames.contains("securityUsers")||t.createObjectStore("securityUsers",{keyPath:"id"}),t.objectStoreNames.contains("visitors")||t.createObjectStore("visitors",{keyPath:"_id"}),t.objectStoreNames.contains("pendingActions")||t.createObjectStore("pendingActions",{keyPath:"id",autoIncrement:!0})},o.onsuccess=()=>e(o.result),o.onerror=()=>s(o.error)})}async function l(e,s){const o=await a();return new Promise((t,c)=>{const n=o.transaction(e,"readwrite"),r=n.objectStore(e);r.clear();for(const i of s)r.put(i);n.oncomplete=()=>t(),n.onerror=()=>c(n.error)})}async function d(e){const s=await a();return new Promise((o,t)=>{const r=s.transaction(e,"readonly").objectStore(e).getAll();r.onsuccess=()=>o(r.result||[]),r.onerror=()=>t(r.error)})}async function S(e,s){const o=await a();return new Promise((t,c)=>{const i=o.transaction(e,"readonly").objectStore(e).get(s);i.onsuccess=()=>t(i.result||null),i.onerror=()=>c(i.error)})}const f={saveStudents:e=>l("students",e),loadStudents:()=>d("students"),saveLogs:e=>l("logs",e),loadLogs:()=>d("logs"),saveStudentProfile:async e=>{const s=await a();return new Promise((o,t)=>{const c=s.transaction("studentProfile","readwrite");c.objectStore("studentProfile").put({key:"me",...e}),c.oncomplete=()=>o(),c.onerror=()=>t(c.error)})},loadStudentProfile:async()=>{const e=await S("studentProfile","me");if(!e)return null;const{key:s,...o}=e;return o},saveStudentLogs:e=>l("studentLogs",e),loadStudentLogs:()=>d("studentLogs"),saveStudentBySid:async e=>{const s=await a(),o={sid:e.studentUid||e.sid||e.SID||e.id||e._id,registrationNo:e.registrationNo,name:e.name,branch:e.branch,batchYear:e.batchYear,profilePhotoUrl:e.profilePhotoUrl||null,profilePhotoThumbUrl:e.profilePhotoThumbUrl||null,updatedAt:Date.now()};if(o.sid)return new Promise((t,c)=>{const n=s.transaction("studentCacheBySid","readwrite");n.objectStore("studentCacheBySid").put(o),n.oncomplete=()=>t(),n.onerror=()=>c(n.error)})},getStudentBySid:async e=>e?S("studentCacheBySid",e):null,pruneStudentCache:async(e=60)=>{try{const s=await a(),o=Date.now()-e*24*60*60*1e3;return new Promise((t,c)=>{const n=s.transaction("studentCacheBySid","readwrite"),r=n.objectStore("studentCacheBySid"),i=r.getAll();i.onsuccess=()=>{const y=i.result||[];for(const u of y)if(!(u!=null&&u.updatedAt)||u.updatedAt<o)try{r.delete(u.sid)}catch{}},n.oncomplete=()=>t(),n.onerror=()=>c(n.error)})}catch{}},saveSecurityUsers:e=>l("securityUsers",e),loadSecurityUsers:()=>d("securityUsers"),saveVisitors:e=>l("visitors",e),loadVisitors:()=>d("visitors"),queueAction:async e=>{const s=await a();return new Promise((o,t)=>{const r=s.transaction("pendingActions","readwrite").objectStore("pendingActions").add({...e,createdAt:Date.now()});r.onsuccess=()=>o(r.result),r.onerror=()=>t(r.error)})},listPendingActions:async()=>d("pendingActions"),removePendingAction:async e=>{const s=await a();return new Promise((o,t)=>{const r=s.transaction("pendingActions","readwrite").objectStore("pendingActions").delete(e);r.onsuccess=()=>o(),r.onerror=()=>t(r.error)})}};export{f as o};
