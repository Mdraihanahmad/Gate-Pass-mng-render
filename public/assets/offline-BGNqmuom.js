const P="gatepass-offline";function d(){return new Promise((t,r)=>{const o=indexedDB.open(P,6);o.onupgradeneeded=()=>{const e=o.result;e.objectStoreNames.contains("students")||e.createObjectStore("students",{keyPath:"id"}),e.objectStoreNames.contains("logs")||e.createObjectStore("logs",{keyPath:"_id"}),e.objectStoreNames.contains("studentProfile")||e.createObjectStore("studentProfile",{keyPath:"key"}),e.objectStoreNames.contains("studentLogs")||e.createObjectStore("studentLogs",{keyPath:"_id"}),e.objectStoreNames.contains("studentCacheBySid")||e.createObjectStore("studentCacheBySid",{keyPath:"sid"}),e.objectStoreNames.contains("studentCacheByPin")||e.createObjectStore("studentCacheByPin",{keyPath:"pinHash"}),e.objectStoreNames.contains("securityUsers")||e.createObjectStore("securityUsers",{keyPath:"id"}),e.objectStoreNames.contains("visitors")||e.createObjectStore("visitors",{keyPath:"_id"}),e.objectStoreNames.contains("pendingActions")||e.createObjectStore("pendingActions",{keyPath:"id",autoIncrement:!0})},o.onsuccess=()=>t(o.result),o.onerror=()=>r(o.error)})}async function p(t,r){const o=await d();return new Promise((e,s)=>{const c=o.transaction(t,"readwrite"),n=c.objectStore(t);n.clear();for(const a of r)n.put(a);c.oncomplete=()=>e(),c.onerror=()=>s(c.error)})}async function u(t){const r=await d();return new Promise((o,e)=>{const n=r.transaction(t,"readonly").objectStore(t).getAll();n.onsuccess=()=>o(n.result||[]),n.onerror=()=>e(n.error)})}async function S(t,r){const o=await d();return new Promise((e,s)=>{const a=o.transaction(t,"readonly").objectStore(t).get(r);a.onsuccess=()=>e(a.result||null),a.onerror=()=>s(a.error)})}async function h(t){try{const o=new TextEncoder().encode(t),e=await crypto.subtle.digest("SHA-256",o),s=new Uint8Array(e);return Array.from(s).map(c=>c.toString(16).padStart(2,"0")).join("")}catch{return""}}const g={saveStudents:t=>p("students",t),loadStudents:()=>u("students"),saveLogs:t=>p("logs",t),loadLogs:()=>u("logs"),saveStudentProfile:async t=>{const r=await d();return new Promise((o,e)=>{const s=r.transaction("studentProfile","readwrite");s.objectStore("studentProfile").put({key:"me",...t}),s.oncomplete=()=>o(),s.onerror=()=>e(s.error)})},loadStudentProfile:async()=>{const t=await S("studentProfile","me");if(!t)return null;const{key:r,...o}=t;return o},saveStudentLogs:t=>p("studentLogs",t),loadStudentLogs:()=>u("studentLogs"),saveStudentBySid:async t=>{const r=await d(),o={sid:t.studentUid||t.sid||t.SID||t.id||t._id,registrationNo:t.registrationNo,name:t.name,branch:t.branch,batchYear:t.batchYear,profilePhotoUrl:t.profilePhotoUrl||null,profilePhotoThumbUrl:t.profilePhotoThumbUrl||null,updatedAt:Date.now()};if(o.sid)return new Promise((e,s)=>{const c=r.transaction("studentCacheBySid","readwrite");c.objectStore("studentCacheBySid").put(o),c.oncomplete=()=>e(),c.onerror=()=>s(c.error)})},getStudentBySid:async t=>t?S("studentCacheBySid",t):null,saveStudentByPin:async(t,r)=>{if(!t||!/^\d{6}$/.test(t))return;const e=await h("gatepass-pepper-v1"+":"+t);if(!e)return;const s=await d(),c={pinHash:e,registrationNo:r.registrationNo,name:r.name,branch:r.branch,batchYear:r.batchYear,sid:r.studentUid||r.sid||r.SID||r.id||r._id,profilePhotoUrl:r.profilePhotoUrl||null,profilePhotoThumbUrl:r.profilePhotoThumbUrl||null,updatedAt:Date.now()};return new Promise((n,a)=>{const i=s.transaction("studentCacheByPin","readwrite");i.objectStore("studentCacheByPin").put(c),i.oncomplete=()=>n(),i.onerror=()=>a(i.error)})},getStudentByPin:async t=>{if(!t||!/^\d{6}$/.test(t))return null;const o=await h("gatepass-pepper-v1"+":"+t);return o?S("studentCacheByPin",o):null},pruneStudentCache:async(t=60)=>{try{const r=await d(),o=Date.now()-t*24*60*60*1e3,e=(s,c)=>new Promise((n,a)=>{const i=r.transaction(s,"readwrite"),y=i.objectStore(s),b=y.getAll();b.onsuccess=()=>{const f=b.result||[];for(const l of f)if(!(l!=null&&l.updatedAt)||l.updatedAt<o)try{y.delete(l[c])}catch{}},i.oncomplete=()=>n(),i.onerror=()=>a(i.error)});await e("studentCacheBySid","sid"),await e("studentCacheByPin","pinHash");return}catch{}},saveSecurityUsers:t=>p("securityUsers",t),loadSecurityUsers:()=>u("securityUsers"),saveVisitors:t=>p("visitors",t),loadVisitors:()=>u("visitors"),queueAction:async t=>{const r=await d();return new Promise((o,e)=>{const n=r.transaction("pendingActions","readwrite").objectStore("pendingActions").add({...t,createdAt:Date.now()});n.onsuccess=()=>o(n.result),n.onerror=()=>e(n.error)})},listPendingActions:async()=>u("pendingActions"),removePendingAction:async t=>{const r=await d();return new Promise((o,e)=>{const n=r.transaction("pendingActions","readwrite").objectStore("pendingActions").delete(t);n.onsuccess=()=>o(),n.onerror=()=>e(n.error)})}};export{g as o};
