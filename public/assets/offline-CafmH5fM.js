const l="gatepass-offline";function d(){return new Promise((e,n)=>{const s=indexedDB.open(l,4);s.onupgradeneeded=()=>{const t=s.result;t.objectStoreNames.contains("students")||t.createObjectStore("students",{keyPath:"id"}),t.objectStoreNames.contains("logs")||t.createObjectStore("logs",{keyPath:"_id"}),t.objectStoreNames.contains("studentProfile")||t.createObjectStore("studentProfile",{keyPath:"key"}),t.objectStoreNames.contains("studentLogs")||t.createObjectStore("studentLogs",{keyPath:"_id"}),t.objectStoreNames.contains("securityUsers")||t.createObjectStore("securityUsers",{keyPath:"id"}),t.objectStoreNames.contains("visitors")||t.createObjectStore("visitors",{keyPath:"_id"}),t.objectStoreNames.contains("pendingActions")||t.createObjectStore("pendingActions",{keyPath:"id",autoIncrement:!0})},s.onsuccess=()=>e(s.result),s.onerror=()=>n(s.error)})}async function u(e,n){const s=await d();return new Promise((t,r)=>{const c=s.transaction(e,"readwrite"),o=c.objectStore(e);o.clear();for(const i of n)o.put(i);c.oncomplete=()=>t(),c.onerror=()=>r(c.error)})}async function a(e){const n=await d();return new Promise((s,t)=>{const o=n.transaction(e,"readonly").objectStore(e).getAll();o.onsuccess=()=>s(o.result||[]),o.onerror=()=>t(o.error)})}async function S(e,n){const s=await d();return new Promise((t,r)=>{const i=s.transaction(e,"readonly").objectStore(e).get(n);i.onsuccess=()=>t(i.result||null),i.onerror=()=>r(i.error)})}const b={saveStudents:e=>u("students",e),loadStudents:()=>a("students"),saveLogs:e=>u("logs",e),loadLogs:()=>a("logs"),saveStudentProfile:async e=>{const n=await d();return new Promise((s,t)=>{const r=n.transaction("studentProfile","readwrite");r.objectStore("studentProfile").put({key:"me",...e}),r.oncomplete=()=>s(),r.onerror=()=>t(r.error)})},loadStudentProfile:async()=>{const e=await S("studentProfile","me");if(!e)return null;const{key:n,...s}=e;return s},saveStudentLogs:e=>u("studentLogs",e),loadStudentLogs:()=>a("studentLogs"),saveSecurityUsers:e=>u("securityUsers",e),loadSecurityUsers:()=>a("securityUsers"),saveVisitors:e=>u("visitors",e),loadVisitors:()=>a("visitors"),queueAction:async e=>{const n=await d();return new Promise((s,t)=>{const o=n.transaction("pendingActions","readwrite").objectStore("pendingActions").add({...e,createdAt:Date.now()});o.onsuccess=()=>s(o.result),o.onerror=()=>t(o.error)})},listPendingActions:async()=>a("pendingActions"),removePendingAction:async e=>{const n=await d();return new Promise((s,t)=>{const o=n.transaction("pendingActions","readwrite").objectStore("pendingActions").delete(e);o.onsuccess=()=>s(),o.onerror=()=>t(o.error)})}};export{b as o};
