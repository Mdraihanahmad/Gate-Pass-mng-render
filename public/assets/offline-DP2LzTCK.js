const S="gatepass-offline";function i(){return new Promise((e,n)=>{const o=indexedDB.open(S,5);o.onupgradeneeded=()=>{const t=o.result;t.objectStoreNames.contains("students")||t.createObjectStore("students",{keyPath:"id"}),t.objectStoreNames.contains("logs")||t.createObjectStore("logs",{keyPath:"_id"}),t.objectStoreNames.contains("studentProfile")||t.createObjectStore("studentProfile",{keyPath:"key"}),t.objectStoreNames.contains("studentLogs")||t.createObjectStore("studentLogs",{keyPath:"_id"}),t.objectStoreNames.contains("studentCacheBySid")||t.createObjectStore("studentCacheBySid",{keyPath:"sid"}),t.objectStoreNames.contains("securityUsers")||t.createObjectStore("securityUsers",{keyPath:"id"}),t.objectStoreNames.contains("visitors")||t.createObjectStore("visitors",{keyPath:"_id"}),t.objectStoreNames.contains("pendingActions")||t.createObjectStore("pendingActions",{keyPath:"id",autoIncrement:!0})},o.onsuccess=()=>e(o.result),o.onerror=()=>n(o.error)})}async function u(e,n){const o=await i();return new Promise((t,c)=>{const s=o.transaction(e,"readwrite"),r=s.objectStore(e);r.clear();for(const a of n)r.put(a);s.oncomplete=()=>t(),s.onerror=()=>c(s.error)})}async function d(e){const n=await i();return new Promise((o,t)=>{const r=n.transaction(e,"readonly").objectStore(e).getAll();r.onsuccess=()=>o(r.result||[]),r.onerror=()=>t(r.error)})}async function l(e,n){const o=await i();return new Promise((t,c)=>{const a=o.transaction(e,"readonly").objectStore(e).get(n);a.onsuccess=()=>t(a.result||null),a.onerror=()=>c(a.error)})}const b={saveStudents:e=>u("students",e),loadStudents:()=>d("students"),saveLogs:e=>u("logs",e),loadLogs:()=>d("logs"),saveStudentProfile:async e=>{const n=await i();return new Promise((o,t)=>{const c=n.transaction("studentProfile","readwrite");c.objectStore("studentProfile").put({key:"me",...e}),c.oncomplete=()=>o(),c.onerror=()=>t(c.error)})},loadStudentProfile:async()=>{const e=await l("studentProfile","me");if(!e)return null;const{key:n,...o}=e;return o},saveStudentLogs:e=>u("studentLogs",e),loadStudentLogs:()=>d("studentLogs"),saveStudentBySid:async e=>{const n=await i(),o={sid:e.studentUid||e.sid||e.SID||e.id||e._id,registrationNo:e.registrationNo,name:e.name,branch:e.branch,batchYear:e.batchYear,profilePhotoUrl:e.profilePhotoUrl||null,profilePhotoThumbUrl:e.profilePhotoThumbUrl||null,updatedAt:Date.now()};if(o.sid)return new Promise((t,c)=>{const s=n.transaction("studentCacheBySid","readwrite");s.objectStore("studentCacheBySid").put(o),s.oncomplete=()=>t(),s.onerror=()=>c(s.error)})},getStudentBySid:async e=>e?l("studentCacheBySid",e):null,saveSecurityUsers:e=>u("securityUsers",e),loadSecurityUsers:()=>d("securityUsers"),saveVisitors:e=>u("visitors",e),loadVisitors:()=>d("visitors"),queueAction:async e=>{const n=await i();return new Promise((o,t)=>{const r=n.transaction("pendingActions","readwrite").objectStore("pendingActions").add({...e,createdAt:Date.now()});r.onsuccess=()=>o(r.result),r.onerror=()=>t(r.error)})},listPendingActions:async()=>d("pendingActions"),removePendingAction:async e=>{const n=await i();return new Promise((o,t)=>{const r=n.transaction("pendingActions","readwrite").objectStore("pendingActions").delete(e);r.onsuccess=()=>o(),r.onerror=()=>t(r.error)})}};export{b as o};
